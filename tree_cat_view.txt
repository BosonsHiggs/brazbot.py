brazbot/argument_descriptions.py:

def command_with_description(bot, name=None, description=None):
    def decorator(func):
        bot.command_handler.register_command(func, name, description)
        return func
    return decorator


Arquivo não encontrado: │  
brazbot/attachments.py:

import aiohttp

class Attachment:
    def __init__(self, attachment_data):
        self.id = attachment_data['id']
        self.filename = attachment_data['filename']
        self.url = attachment_data['url']
        self.content_type = attachment_data['content_type']

    async def to_file(self):
        async with aiohttp.ClientSession() as session:
            async with session.get(self.url) as response:
                if response.status == 200:
                    return {
                        'filename': self.filename,
                        'data': await response.read(),
                        'content_type': self.content_type
                    }
                else:
                    raise Exception(f"Failed to download file: {response.status}")


Arquivo não encontrado: │  
brazbot/autocomplete.py:

def autocomplete_command(bot, name=None, description=None):
    def decorator(func):
        bot.command_handler.register_command(func, name, description)
        func._is_autocomplete = True
        return func

    def autocomplete(option):
        def decorator(func):
            if not hasattr(func, 'autocomplete_options'):
                func.autocomplete_options = []
            func.autocomplete_options.append(option)
            bot.command_handler.register_autocomplete(func, option)
            return func
        return decorator
    
    decorator.autocomplete = autocomplete
    return decorator


Arquivo não encontrado: │  
brazbot/bot_itimized.py:

import json
import asyncio
import aiohttp
import logging
import zlib

from brazbot.events import EventHandler
from brazbot.commands import CommandHandler
from brazbot.message_handler import MessageHandler
from brazbot.cache import Cache

# Mapeamento de intents
INTENTS = {
    "GUILDS": 1 << 0,
    "GUILD_MEMBERS": 1 << 1,
    "GUILD_BANS": 1 << 2,
    "GUILD_EMOJIS_AND_STICKERS": 1 << 3,
    "GUILD_INTEGRATIONS": 1 << 4,
    "GUILD_WEBHOOKS": 1 << 5,
    "GUILD_INVITES": 1 << 6,
    "GUILD_VOICE_STATES": 1 << 7,
    "GUILD_PRESENCES": 1 << 8,
    "GUILD_MESSAGES": 1 << 9,
    "GUILD_MESSAGE_REACTIONS": 1 << 10,
    "GUILD_MESSAGE_TYPING": 1 << 11,
    "DIRECT_MESSAGES": 1 << 12,
    "DIRECT_MESSAGE_REACTIONS": 1 << 13,
    "DIRECT_MESSAGE_TYPING": 1 << 14,
    "MESSAGE_CONTENT": 1 << 15,
    "GUILD_SCHEDULED_EVENTS": 1 << 16
}

logging.basicConfig(level=logging.DEBUG)

class DiscordBot:
    def __init__(self, token, command_prefix=None, intents=None):
        self.token = token
        self.command_prefix = command_prefix
        self.intents = self.calculate_intents(intents)
        self.base_url = "https://discord.com/api/v10"
        self.headers = {
            "Authorization": f"Bot {self.token}",
            "Content-Type": "application/json"
        }
        self.event_handler = EventHandler()
        self.command_handler = CommandHandler(self)
        self.message_handler = MessageHandler(self.token)
        self.cache = Cache()
        self.application_id = None
        self.heartbeat_interval = None
        self.heartbeat_task = None
        self.session_id = None
        self.sequence = None
        self.cogs = []
        self.compress = True
        self.zlib_inflater = zlib.decompressobj()

        # Register events automatically
        self.auto_register_events()

    def calculate_intents(self, intents):
        if intents is None:
            return sum(INTENTS.values())
        elif isinstance(intents, list):
            return sum(INTENTS[intent] for intent in intents)
        return intents

    def event(self, func):
        event_name = func.__name__
        self.event_handler.register(event_name, func)
        return func

    def command(self, name=None, description=None):
        def decorator(func):
            self.command_handler.register_command(func, name, description)
            return func
        return decorator

    def auto_register_events(self):
        for attr_name in dir(self):
            if attr_name.startswith("on_"):
                attr = getattr(self, attr_name)
                if callable(attr):
                    self.event(attr)

    def add_cog(self, cog):
        self.cogs.append(cog)
        for attr_name in dir(cog):
            attr = getattr(cog, attr_name)
            if callable(attr):
                if attr_name.startswith("on_"):
                    self.event(attr)
                elif hasattr(attr, "_command"):
                    self.command(attr._command["name"], attr._command["description"])(attr)

    async def send_heartbeat(self, ws):
        while True:
            await asyncio.sleep(self.heartbeat_interval / 1000)
            await ws.send_json({"op": 1, "d": self.sequence})
            logging.info("Heartbeat sent")

    async def connect_gateway(self):
        async with aiohttp.ClientSession() as session:
            async with session.get(f"{self.base_url}/gateway/bot", headers=self.headers) as resp:
                data = await resp.json()
                gateway_url = data['url']
                shards = data['shards']
                session_start_limit = data['session_start_limit']
                max_concurrency = session_start_limit['max_concurrency']
                return gateway_url, shards, max_concurrency

    async def start(self):
        gateway_url, shards, max_concurrency = await self.connect_gateway()
        shard_id = 0

        while True:
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.ws_connect(f"{gateway_url}?v=10&encoding=json&compress=zlib-stream") as ws:
                        if self.session_id and self.sequence:
                            await ws.send_json({
                                "op": 6,
                                "d": {
                                    "token": self.token,
                                    "session_id": self.session_id,
                                    "seq": self.sequence
                                }
                            })
                            logging.info("Resuming session")
                        else:
                            await ws.send_json({
                                "op": 2,
                                "d": {
                                    "token": self.token,
                                    "intents": self.intents,
                                    "properties": {
                                        "$os": "linux",
                                        "$browser": "my_library",
                                        "$device": "my_library"
                                    },
                                    "shard": [shard_id, shards]
                                }
                            })
                            logging.info("Starting new session")
                        
                        async for msg in ws:
                            if msg.type == aiohttp.WSMsgType.BINARY:
                                message = self.zlib_inflater.decompress(msg.data)
                                message = json.loads(message)
                            elif msg.type == aiohttp.WSMsgType.TEXT:
                                message = json.loads(msg.data)

                            self.sequence = message.get('s')
                            
                            if message['op'] == 10:  # Opcode for Hello, contains heartbeat_interval
                                self.heartbeat_interval = message['d']['heartbeat_interval']
                                if self.heartbeat_task:
                                    self.heartbeat_task.cancel()
                                self.heartbeat_task = asyncio.create_task(self.send_heartbeat(ws))
                            if message['t'] == 'READY':
                                self.session_id = message['d']['session_id']
                                self.application_id = message['d']['application']['id']
                                logging.info(f"READY message received: {message}")
                                await self.event_handler.handle_event({
                                    't': 'on_ready',
                                    'd': message['d']
                                })
                            elif message['t'] == 'MESSAGE_CREATE':
                                logging.info(f"Message received: {message}")
                                asyncio.create_task(self.event_handler.handle_event(message))
                                asyncio.create_task(self.command_handler.handle_command(message))
                            elif message['t'] == 'INTERACTION_CREATE':
                                logging.info(f"Interaction received: {message}")
                                await self.event_handler.handle_event({
                                    't': 'on_interaction_create',
                                    'd': message['d']
                                })
                            elif message['t'] == 'ERROR':
                                logging.error(f"Error received: {message}")
                                await self.event_handler.handle_event({
                                    't': 'on_error',
                                    'd': message['d']
                                })
                            elif message['op'] == 1:
                                await ws.send_json({"op": 1, "d": self.sequence})
                                logging.info("Heartbeat response sent")

                            elif msg.type in {aiohttp.WSMsgType.ERROR, aiohttp.WSMsgType.CLOSED}:
                                logging.warning(f"WebSocket closed with message: {msg.data}")
                                if self.heartbeat_task:
                                    self.heartbeat_task.cancel()
                                break
            except aiohttp.ClientResponseError as e:
                if e.status == 429:  # Rate limit
                    retry_after = int(e.headers.get("Retry-After", 1))
                    logging.error(f"Rate limited. Retrying after {retry_after} seconds.")
                    await asyncio.sleep(retry_after)
                else:
                    logging.error(f"Exception in WebSocket connection: {e}")
            except Exception as e:
                logging.error(f"Exception: {e}")

            logging.info("Reconnecting in 5 seconds...")
            await asyncio.sleep(5)


Arquivo não encontrado: │  
brazbot/bot.py:

import json
import asyncio
import aiohttp
import logging
from aiohttp import ClientResponseError
from brazbot.events import EventHandler
from brazbot.commands import CommandHandler
from brazbot.message_handler import MessageHandler
from brazbot.cache import Cache
"""
SEE: 
    1. https://discord.com/developers/docs/topics/rate-limits#global-rate-limit
"""

# Mapeamento de intents
INTENTS = {
    "GUILDS": 1 << 0,
    "GUILD_MEMBERS": 1 << 1,
    "GUILD_BANS": 1 << 2,
    "GUILD_EMOJIS_AND_STICKERS": 1 << 3,
    "GUILD_INTEGRATIONS": 1 << 4,
    "GUILD_WEBHOOKS": 1 << 5,
    "GUILD_INVITES": 1 << 6,
    "GUILD_VOICE_STATES": 1 << 7,
    "GUILD_PRESENCES": 1 << 8,
    "GUILD_MESSAGES": 1 << 9,
    "GUILD_MESSAGE_REACTIONS": 1 << 10,
    "GUILD_MESSAGE_TYPING": 1 << 11,
    "DIRECT_MESSAGES": 1 << 12,
    "DIRECT_MESSAGE_REACTIONS": 1 << 13,
    "DIRECT_MESSAGE_TYPING": 1 << 14,
    "MESSAGE_CONTENT": 1 << 15,
    "GUILD_SCHEDULED_EVENTS": 1 << 16
}

logging.basicConfig(level=logging.DEBUG)
logging.getLogger().setLevel(logging.CRITICAL)

#OP codes: https://discord.com/developers/docs/topics/opcodes-and-status-codes
class DiscordBot:
    def __init__(self, token, command_prefix=None, intents=None, num_shards=1, shard_id=0):
        self.token = token
        self.command_prefix = command_prefix
        self.intents = self.calculate_intents(intents)
        self.num_shards = num_shards
        self.shard_id = shard_id
        self.base_url = "https://discord.com/api/v10"
        self.headers = {
            "Authorization": f"Bot {self.token}",
            "Content-Type": "application/json"
        }

        self.event_handler = EventHandler()
        self.command_handler = CommandHandler(self)
        self.message_handler = MessageHandler(self.token)
        self.cache = Cache()
        self.application_id = None
        self.heartbeat_interval = None
        self.heartbeat_task = None
        self.session_id = None
        self.sequence = None
        self.cogs = []

        # Register events automatically
        self.auto_register_events()

    def calculate_intents(self, intents):
        if intents is None:
            return sum(INTENTS.values())
        elif isinstance(intents, list):
            return sum(INTENTS[intent] for intent in intents)
        return intents

    def event(self, func):
        event_name = func.__name__
        self.event_handler.register(event_name, func)
        return func

    def command(self, name=None, description=None):
        def decorator(func):
            self.command_handler.register_command(func, name, description)
            return func
        return decorator

    def auto_register_events(self):
        for attr_name in dir(self):
            if attr_name.startswith("on_"):
                attr = getattr(self, attr_name)
                if callable(attr):
                    self.event(attr)

    def add_cog(self, cog):
        self.cogs.append(cog)
        for attr_name in dir(cog):
            attr = getattr(cog, attr_name)
            if callable(attr):
                if attr_name.startswith("on_"):
                    self.event(attr)
                elif hasattr(attr, "_command"):
                    self.command(attr._command["name"], attr._command["description"])(attr)

    async def setup_hook(self):
        pass

    async def send_heartbeat(self, ws):
        while True:
            await asyncio.sleep(self.heartbeat_interval / 1000)
            await ws.send_json({"op": 1, "d": self.sequence})

    async def handle_rate_limit(self, response):
        if response.status == 429:
            retry_after = int(response.headers.get("Retry-After", 1))
            is_global = response.headers.get("X-RateLimit-Global", False)
            rate_limit_scope = response.headers.get("X-RateLimit-Scope", "unknown")
            
            logging.error(f"Rate limited. Retry after {retry_after} seconds. Scope: {rate_limit_scope}. Global: {is_global}")
            await asyncio.sleep(retry_after)

    async def change_presence(self, activity_name, activity_type=0):
        presence_payload = {
            "op": 3,
            "d": {
                "since": None,
                "activities": [
                    {
                        "name": activity_name,
                        "type": activity_type
                    }
                ],
                "status": "online",
                "afk": False
            }
        }
        async with aiohttp.ClientSession() as session:
            async with session.ws_connect("wss://gateway.discord.gg/?v=10&encoding=json") as ws:
                await ws.send_json(presence_payload)

    async def start(self):
        await self.setup_hook()
        while True:
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.ws_connect(f"wss://gateway.discord.gg/?v=10&encoding=json") as ws:
                        identify_payload = {
                            "op": 2,
                            "d": {
                                "token": self.token,
                                "intents": self.intents,
                                "properties": {
                                    "$os": "linux",
                                    "$browser": "my_library",
                                    "$device": "my_library"
                                },
                                "shard": [self.shard_id, self.num_shards]
                            }
                        }

                        if self.session_id and self.sequence:
                            await ws.send_json({
                                "op": 6,
                                "d": {
                                    "token": self.token,
                                    "session_id": self.session_id,
                                    "seq": self.sequence
                                }
                            })
                        else:
                            await ws.send_json(identify_payload)

                        async for msg in ws:
                            """
                            NAME    DESCRIPTION
                            READY   non-subscription event sent immediately after connecting, contains server information
                            ERROR   non-subscription event sent when there is an error, including command responses
                            GUILD_STATUS    sent when a subscribed server's state changes
                            GUILD_CREATE    sent when a guild is created/joined on the client
                            CHANNEL_CREATE  sent when a channel is created/joined on the client
                            VOICE_CHANNEL_SELECT    sent when the client joins a voice channel
                            VOICE_STATE_CREATE  sent when a user joins a subscribed voice channel
                            VOICE_STATE_UPDATE  sent when a user's voice state changes in a subscribed voice channel (mute, volume, etc.)
                            VOICE_STATE_DELETE  sent when a user parts a subscribed voice channel
                            VOICE_SETTINGS_UPDATE   sent when the client's voice settings update
                            VOICE_CONNECTION_STATUS sent when the client's voice connection status changes
                            SPEAKING_START  sent when a user in a subscribed voice channel speaks
                            SPEAKING_STOP   sent when a user in a subscribed voice channel stops speaking
                            MESSAGE_CREATE  sent when a message is created in a subscribed text channel
                            MESSAGE_UPDATE  sent when a message is updated in a subscribed text channel
                            MESSAGE_DELETE  sent when a message is deleted in a subscribed text channel
                            NOTIFICATION_CREATE sent when the client receives a notification (mention or new message in eligible channels)
                            ACTIVITY_JOIN   sent when the user clicks a Rich Presence join invite in chat to join a game
                            ACTIVITY_SPECTATE   sent when the user clicks a Rich Presence spectate invite in chat to spectate a game
                            ACTIVITY_JOIN_REQUEST   sent when the user receives a Rich Presence Ask to Join request
                            """
                            if msg.type == aiohttp.WSMsgType.TEXT:
                                message = json.loads(msg.data)
                                self.sequence = message.get('s')

                                if message['op'] == 10:  # Opcode for Hello, contains heartbeat_interval
                                    self.heartbeat_interval = message['d']['heartbeat_interval']
                                    if self.heartbeat_task:
                                        self.heartbeat_task.cancel()
                                    self.heartbeat_task = asyncio.create_task(self.send_heartbeat(ws))
                                if message['t'] == 'READY':
                                    self.session_id = message['d']['session_id']
                                    self.application_id = message['d']['application']['id']
                                    await self.event_handler.handle_event({
                                        't': 'on_ready',
                                        'd': message['d']
                                    })
                                elif message['t'] == 'MESSAGE_CREATE':
                                    asyncio.create_task(self.event_handler.handle_event(message))
                                    asyncio.create_task(self.command_handler.handle_command(message))
                                elif message['t'] == 'INTERACTION_CREATE':
                                    valor = message.get('d', None)
                                    if valor is not None:
                                        if ('dropdown_select' or 'button_click' in message['d']['data']):
                                            await self.event_handler.handle_event({
                                            't': 'on_interaction_create',
                                            'd': message['d']
                                        })
                                        elif ('dropdown_select' or 'button_click' in message['components']):
                                            await self.event_handler.handle_event({
                                            't': 'on_interaction_sendcccc',
                                            'd': message['d']
                                        })
                                        if 'autocomplete' in message['d']['data']:
                                            asyncio.create_task(self.command_handler.handle_autocomplete(message['d']))

                                        else:
                                            asyncio.create_task(self.event_handler.handle_event(message))
                                            asyncio.create_task(self.command_handler.handle_command(message))
                                elif message['t'] == 'ERROR':
                                    await self.event_handler.handle_event({
                                        't': 'on_error',
                                        'd': message['d']
                                    })
                            elif msg.type in {aiohttp.WSMsgType.ERROR, aiohttp.WSMsgType.CLOSED}:
                                if self.heartbeat_task:
                                    self.heartbeat_task.cancel()
                                break
            except ClientResponseError as e:
                await self.handle_rate_limit(e.response)
            except Exception as e:
                logging.error(f"Unexpected exception: {e}")

            print("Reconnecting in 5 seconds...")
            await asyncio.sleep(5)


Arquivo não encontrado: │  
brazbot/buttons.py:

class Button:
    def __init__(self, label, style, custom_id, url=None, disabled=False, emoji=None):
        self.label = label
        self.style = style
        self.custom_id = custom_id
        self.url = url
        self.disabled = disabled
        self.emoji = emoji

    def to_dict(self):
        data = {
            "type": 2,
            "label": self.label,
            "style": self.style,
            "custom_id": self.custom_id,
            "disabled": self.disabled
        }

        if self.url:
            data["url"] = self.url
        if self.emoji:
            data["emoji"] = self.emoji

        return data

    @property
    def to_component(self):
        return {"type": 1, "components": [self.to_dict()]}


Arquivo não encontrado: │  
brazbot/cache.py:

import time

class Cache:
    def __init__(self):
        self.cache = {}
        self.expiry_times = {}

    def set(self, key, value, ttl=300):
        self.cache[key] = value
        self.expiry_times[key] = time.time() + ttl

    def get(self, key):
        if key in self.cache and time.time() < self.expiry_times[key]:
            return self.cache[key]
        elif key in self.cache:
            del self.cache[key]
            del self.expiry_times[key]
        return None


Arquivo não encontrado: │  
brazbot/channels.py:

import aiohttp
from datetime import datetime

class Channel:
    def __init__(self, data, bot=None):
        self.bot = bot
        self.id = data.get('id')
        self.name = data.get('name')
        self.category = data.get('category')
        self.changed_roles = data.get('changed_roles', [])
        self.created_at = datetime.fromtimestamp(((int(self.id) >> 22) + 1420070400000) / 1000)
        self.guild = data.get('guild')
        self.jump_url = data.get('jump_url')
        self.mention = f"<#{self.id}>"
        self.overwrites = data.get('overwrites', {})
        self.permissions_synced = data.get('permissions_synced', False)
        self.position = data.get('position')

    @classmethod
    async def from_channel_id(cls, bot, guild_id, channel_id):
        url = f"https://discord.com/api/v10/guilds/{guild_id}/channels/{channel_id}"
        headers = {
            "Authorization": f"Bot {bot.token}"
        }

        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    data = await response.json()
                    return cls(data, bot)
                else:
                    raise Exception(f"Failed to fetch channel data: {response.status}")

    def __str__(self):
        return self.name

    # Methods to interact with the Discord API
    async def clone(self, name=None, reason=None):
        url = f"https://discord.com/api/v10/channels/{self.id}/clone"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        json_data = {
            "name": name or self.name,
            "reason": reason
        }
        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers=headers, json=json_data) as response:
                if response.status != 200:
                    raise Exception(f"Failed to clone channel {self.id}: {response.status}")

    async def create_invite(self, max_age=86400, max_uses=0, temporary=False, unique=True):
        url = f"https://discord.com/api/v10/channels/{self.id}/invites"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        json_data = {
            "max_age": max_age,
            "max_uses": max_uses,
            "temporary": temporary,
            "unique": unique
        }
        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers=headers, json=json_data) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    raise Exception(f"Failed to create invite for channel {self.id}: {response.status}")

    async def delete(self, reason=None):
        url = f"https://discord.com/api/v10/channels/{self.id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        async with aiohttp.ClientSession() as session:
            async with session.delete(url, headers=headers) as response:
                if response.status != 204:
                    raise Exception(f"Failed to delete channel {self.id}: {response.status}")

    async def invites(self):
        url = f"https://discord.com/api/v10/channels/{self.id}/invites"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    raise Exception(f"Failed to fetch invites for channel {self.id}: {response.status}")

    async def move(self, position, parent_id=None, lock_permissions=False, reason=None):
        url = f"https://discord.com/api/v10/channels/{self.id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        json_data = {
            "position": position,
            "parent_id": parent_id,
            "lock_permissions": lock_permissions,
            "reason": reason
        }
        async with aiohttp.ClientSession() as session:
            async with session.patch(url, headers=headers, json=json_data) as response:
                if response.status != 200:
                    raise Exception(f"Failed to move channel {self.id}: {response.status}")

    def overwrites_for(self, member_or_role):
        return self.overwrites.get(str(member_or_role.id))

    async def permissions_for(self, member_or_role):
        url = f"https://discord.com/api/v10/channels/{self.id}/permissions/{member_or_role.id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    raise Exception(f"Failed to fetch permissions for {member_or_role.id} in channel {self.id}: {response.status}")

    async def set_permissions(self, member_or_role, allow, deny, reason=None):
        url = f"https://discord.com/api/v10/channels/{self.id}/permissions/{member_or_role.id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        json_data = {
            "allow": allow,
            "deny": deny,
            "reason": reason
        }
        async with aiohttp.ClientSession() as session:
            async with session.put(url, headers=headers, json=json_data) as response:
                if response.status != 204:
                    raise Exception(f"Failed to set permissions for {member_or_role.id} in channel {self.id}: {response.status}")


Arquivo não encontrado: │  
brazbot/cogs.py:

class Cog:
    def __init__(self, bot):
        self.bot = bot

    def event(self, func):
        event_name = func.__name__
        self.bot.event_handler.register(event_name, func)
        return func

    def command(self, name=None, description=None):
        def decorator(func):
            self.bot.command_handler.register_command(func, name, description)
            return func
        return decorator


Arquivo não encontrado: │  
brazbot/commands.py:

import aiohttp
import logging
import json
from typing import Union, Literal, get_args, _GenericAlias
from brazbot.greedy_union import Greedy
from brazbot.attachments import Attachment
from brazbot.snowflake import Snowflake
from brazbot.member import Member
from brazbot.roles import Role
from brazbot.channels import Channel
from brazbot.guilds import Guild

logging.basicConfig(level=logging.DEBUG)
#logging.getLogger().setLevel(logging.CRITICAL)

class CommandContext:
	def __init__(self, bot, message, interaction=None):
		self.bot = bot
		self.message = message
		self.interaction = interaction
		self.channel_id = message.get('channel_id')
		self.author = message.get('author') or (interaction.get('member', {}).get('user') if interaction else None)
		self.content = message.get('content')
		self.guild_id = message.get('guild_id') if message.get('guild_id') else (interaction.get('guild_id') if interaction else None)
		self.options = {opt['name']: opt['value'] for opt in (interaction['data'].get('options', []) if interaction and 'data' in interaction else [])}

	async def defer(self, ephemeral=False):
		url = f"https://discord.com/api/v10/interactions/{self.interaction['id']}/{self.interaction['token']}/callback"
		json_data = {
			"type": 5  # Type 5 is for deferred responses
		}
		if ephemeral:
			json_data["data"] = {"flags": 64}

		async with aiohttp.ClientSession() as session:
			async with session.post(url, json=json_data) as response:
				if response.status != 204:
					logging.error(f"Failed to defer interaction: {response.status}")
				else:
					logging.info("Interaction deferred successfully")

	async def send_modal(self, title, custom_id, data):
		await self.bot.message_handler.send_modal(self.interaction, title, custom_id, data)

	async def send_followup_message(self, content=None, embed=None, embeds=None, files=None, components=None, ephemeral=False):
		await self.bot.message_handler.send_followup_message(self.bot.application_id, self.interaction["token"], content, embed, embeds, files, components, ephemeral)

class CommandHandler:
	def __init__(self, bot):
		self.bot = bot
		self.commands = {}
		self.autocomplete_functions = {}

	def register_command(self, func, name=None, description=None):
		name = name or func.__name__
		description = description or func.__doc__ or "No description provided"

		options = []
		for param_name, param in func.__annotations__.items():
			option = {"name": param_name, "required": True}
			if param == str:
				option["type"] = 3  # STRING
				if hasattr(func, "autocomplete_options") and param_name in func.autocomplete_options:
					option["autocomplete"] = True
			elif param == int:
				option["type"] = 4  # INTEGER
			elif param == float:
				option["type"] = 10  # NUMBER
			elif param == bytes:  # Handle file attachments
				option["type"] = 11  # ATTACHMENT
			elif param == bool:
				option["type"] = 5  # BOOLEAN
			elif param == Attachment:
				option["type"] = 11  # ATTACHMENT
			elif isinstance(param, type) and issubclass(param, Member):
				option["type"] = 6  # USER type (custom Member object)
			elif param == dict and "channel" in param_name:
				option["type"] = 7  # CHANNEL
			elif isinstance(param, type) and issubclass(param, Guild):
				option["type"] = 9  # GUILD type (custom Guild object)
			elif isinstance(param, type) and issubclass(param, Role):
				option["type"] = 8  # ROLE type (custom Role object)
			elif isinstance(param, type) and issubclass(param, Channel):
				option["type"] = 7  # CHANNEL type (custom Channel object)
			elif isinstance(param, type) and issubclass(param, Thread):
				option["type"] = 11  # THREAD type (custom Thread object)
			elif isinstance(param, _GenericAlias) and param.__origin__ is Literal:
				option["type"] = 3  # STRING
				option["choices"] = [{"name": v, "value": v} for v in get_args(param)]
			elif isinstance(param, _GenericAlias) and param.__origin__ is Union and len(param.__args__) == 2 and param.__args__[1] is type(None):
				option["type"] = 3  # STRING
				option["required"] = False
			elif isinstance(param, _GenericAlias) and param.__origin__ is Greedy:
				option["type"] = 3  # STRING
				option["required"] = False
			elif isinstance(param, _GenericAlias) and param.__origin__ is Union:
				if str in param.__args__:
					option["type"] = 3
				if int in param.__args__:
					option["type"] = 4
				if float in param.__args__:
					option["type"] = 10

			if hasattr(func, "parameter_descriptions") and param_name in func.parameter_descriptions:
				option["description"] = func.parameter_descriptions[param_name]
			else:
				option["description"] = param_name  # Default to the parameter name if no description is provided

			options.append(option)

		self.commands[name] = {
			"func": func,
			"description": description,
			"options": options,
			"type": 1  # 1 indicates a CHAT_INPUT command
		}

		logging.debug(f"Registered command: {name} with options: {options}")

		#logging.debug(f"Registered command: {name} with options: {options}")

	def register_autocomplete(self, func, command_name, option_name):
		if command_name not in self.commands:
			raise ValueError(f"Command '{command_name}' not found")
		for option in self.commands[command_name]["options"]:
			if option["name"] == option_name:
				option["autocomplete"] = True
				self.autocomplete_functions[(command_name, option_name)] = func
				return
		raise ValueError(f"Option '{option_name}' not found in command '{command_name}'")

	async def send_autocomplete_response(self, interaction, suggestions):
		response_data = {
			"type": 8,  # Autocomplete result type
			"data": {
				"choices": suggestions
			}
		}
		url = f"https://discord.com/api/v10/interactions/{interaction['id']}/{interaction['token']}/callback"
		async with aiohttp.ClientSession() as session:
			async with session.post(url, json=response_data) as response:
				if response.status != 200:
					logging.error(f"Failed to send autocomplete response: {response.status}")


	async def handle_autocomplete(self, interaction):
		command_name = interaction['data']['name']
		options = interaction['data']['options']
		focused_option = next((opt for opt in options if opt.get('focused')), None)
		if focused_option:
			option_name = focused_option['name']
			if (command_name, option_name) in self.autocomplete_functions:
				await self.autocomplete_functions[(command_name, option_name)](interaction)
			else:
				logging.warning(f"No autocomplete function registered for command '{command_name}' and option '{option_name}'")


	#logging.debug(f"Handling command for message: {message}")
	async def handle_command(self, message):
		logging.debug(f"Handling command for message: {message}")
		if 'content' in message['d']:
			content = message['d']['content']
			if self.bot.command_prefix and content.startswith(self.bot.command_prefix):
				command_name, *args = content[len(self.bot.command_prefix):].split()
				if command_name in self.commands:
					ctx = CommandContext(self.bot, message['d'])
					await self.commands[command_name]["func"](ctx, *args)
		elif message['d']['type'] == 2:  # Slash command type
			command_name = message['d']['data']['name']
			if command_name in self.commands:
				ctx = CommandContext(self.bot, message['d'], interaction=message['d'])
				self.bot.interaction = message['d']  # Set the interaction attribute
				options = message['d']['data'].get('options', [])
				args = {}
				for opt in options:
					if opt['type'] == 6:  # USER type
						args[opt['name']] = await Member.from_user_id(self.bot, opt['value'], ctx.guild_id)
					elif opt['type'] == 8:  # ROLE type
						args[opt['name']] = await Role.from_role_id(self.bot, ctx.guild_id, opt['value'])
					elif opt['type'] == 7:  # CHANNEL type
						args[opt['name']] = await Channel.from_channel_id(self.bot, ctx.guild_id, opt['value'])
					elif opt['type'] == 9:  # GUILD type 
						args[opt['name']] = await Guild.from_guild_id(self.bot, ctx.guild_id)
					elif opt['type'] == 11:  # THREAD type 
						args[opt['name']] = await Thread.from_thread_id(cls, self.bot, ctx.guild_id, opt['value'])
					else:
						args[opt['name']] = opt['value']
				logging.debug(f"Executing command: {command_name} with options: {options}")
				await self.commands[command_name]["func"](ctx, **args)
		elif message['d']['type'] == 4:  # Autocomplete interaction
			await self.handle_autocomplete(message['d'])

	async def get_existing_commands(self, guild_id=None):
		url = f"{self.bot.base_url}/applications/{self.bot.application_id}/commands"
		if guild_id:
			url = f"{self.bot.base_url}/applications/{self.bot.application_id}/guilds/{guild_id}/commands"

		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=self.bot.headers) as response:
				if response.status == 200:
					return {cmd['name']: cmd for cmd in await response.json()}
				return {}

	async def sync_commands(self, guild_id=None):
		try:
			if not Snowflake.is_valid(self.bot.application_id):
				raise ValueError(f"Invalid application_id: {self.bot.application_id}")

			current_commands = [
				{
					"name": name,
					"description": cmd["description"],
					"options": cmd["options"],
					"type": 1  # 1 indica um comando CHAT_INPUT
				} for name, cmd in self.commands.items()
			]

			existing_commands = await self.get_existing_commands(guild_id)
			transformed_existing_commands = [
				{
					"name": cmd['name'],
					"description": cmd['description'],
					"options": [
						{
							"name": opt['name'],
							"description": opt.get('description', ''),
							"type": opt['type'],
							"required": opt.get('required', False)
						} for opt in cmd.get('options', [])
					],
					"type": cmd['type']
				} for cmd in existing_commands.values()
			]

			if self.commands_changed(current_commands, transformed_existing_commands):
				url = f"{self.bot.base_url}/applications/{self.bot.application_id}/commands"
				if guild_id:
					url = f"{self.bot.base_url}/applications/{self.bot.application_id}/guilds/{guild_id}/commands"

				async with aiohttp.ClientSession() as session:
					async with session.put(url, headers=self.bot.headers, json=current_commands) as response:
						response_text = await response.text()
						if response.status != 200:
							logging.error(f"Failed to sync commands: {response.status}")
							logging.error(f"Response: {response_text}")
							return f"Failed to sync commands: {response.status}\nResponse: {response_text}"
						else:
							logging.info("Commands synced successfully: " + response_text)
							return f"Commands synced successfully: {response_text}"
			else:
				logging.info("No changes in commands. Sync skipped.")
				return "No changes in commands. Sync skipped."
		except Exception as e:
			logging.error(f"Exception occurred while syncing commands: {e}")
			return f"Exception occurred while syncing commands: {e}"

	async def send_response(self, content):
		url = f"https://discord.com/api/v10/interactions/{self.interaction['id']}/{self.interaction['token']}/callback"
		json_data = {
			"type": 4,
			"data": {
				"content": content
			}
		}
	   #logging.debug(f"Sending response to interaction: {json_data}")
		async with aiohttp.ClientSession() as session:
			async with session.post(url, json=json_data) as response:
				"""
				if response.status != 200:
				   #logging.error(f"Failed to send response: {response.status}")
				   #logging.error(f"Response text: {await response.text()}")
				else:
				   #logging.info("Response sent successfully.")
				"""
				return await response.json()
	
	def commands_changed(self, current_commands, existing_commands):
		if len(current_commands) != len(existing_commands):
		   #logging.debug("Number of commands changed.")
			return True

		for current, existing in zip(current_commands, existing_commands):
			if current["name"] != existing["name"]:
			   #logging.debug(f"Command name changed: {current['name']} != {existing['name']}")
				return True
			if current["description"] != existing["description"]:
			   #logging.debug(f"Description for command {current['name']} changed: {current['description']} != {existing['description']}")
				return True
			if current["options"] != existing["options"]:
			   #logging.debug(f"Options for command {current['name']} changed.")
				return True

		return False

   
	async def check_rate_limits(self):
		endpoints = [
			"/gateway",
			"/channels/{self.channel_id}/messages",
			"/guilds/{self.guild_id}/members/{self.user_id}"
		]
		results = []
		async with aiohttp.ClientSession() as session:
			for endpoint in endpoints:
				url = f"{self.bot.base_url}{endpoint}"
				async with session.get(url, headers=self.bot.headers) as response:
					rate_limit_info = {
						"endpoint": endpoint,
						"status": response.status,
						"limit": response.headers.get("X-RateLimit-Limit"),
						"remaining": response.headers.get("X-RateLimit-Remaining"),
						"reset": response.headers.get("X-RateLimit-Reset"),
						"reset_after": response.headers.get("X-RateLimit-Reset-After"),
						"bucket": response.headers.get("X-RateLimit-Bucket"),
						"retry_after": response.headers.get("Retry-After"),
						"global": response.headers.get("X-RateLimit-Global"),
					}
					results.append(rate_limit_info)
				   #logging.info(f"Rate limit info for {endpoint}: {rate_limit_info}")
		return results


Arquivo não encontrado: │  
brazbot/decorators.py:

import aiohttp
import functools
from brazbot.cache import Cache

cache = Cache()

def sync_slash_commands(guild_id=None):
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(ctx, *args, **kwargs):
            await func(ctx, *args, **kwargs)
            await ctx.bot.command_handler.sync_commands(guild_id)
        wrapper._slash_command = True
        wrapper._guild_id = guild_id
        return wrapper
    return decorator

def describe(**descriptions):
    def decorator(func):
        if not hasattr(func, "parameter_descriptions"):
            func.parameter_descriptions = {}
        func.parameter_descriptions.update(descriptions)
        return func
    return decorator


def is_admin():
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(ctx, *args, **kwargs):
            guild_id = ctx.guild_id
            author_id = ctx.author['id']
            
            guild_info = cache.get(f"guild_info_{guild_id}")
            if not guild_info:
                async with aiohttp.ClientSession() as session:
                    async with session.get(f"https://discord.com/api/v10/guilds/{guild_id}", headers=ctx.bot.headers) as response:
                        guild_info = await response.json()
                cache.set(f"guild_info_{guild_id}", guild_info)
            if guild_info.get('owner_id') == author_id:
                return await func(ctx, *args, **kwargs)
            
            roles = ctx.member['roles']
            guild_roles = cache.get(f"guild_roles_{guild_id}")
            if not guild_roles:
                async with aiohttp.ClientSession() as session:
                    async with session.get(f"https://discord.com/api/v10/guilds/{guild_id}/roles", headers=ctx.bot.headers) as response:
                        guild_roles = await response.json()
                cache.set(f"guild_roles_{guild_id}", guild_roles)
            admin_role_ids = [role['id'] for role in guild_roles if int(role['permissions']) & 0x8]
            if any(role_id in roles for role_id in admin_role_ids):
                return await func(ctx, *args, **kwargs)
            else:
                await ctx.bot.event_handler.handle_event({
                    't': 'on_error',
                    'd': {'message': 'Você precisa ser um administrador ou o dono do servidor para usar este comando.', 'channel_id': ctx.channel_id}
                })
        return wrapper
    return decorator

def is_owner():
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(ctx, *args, **kwargs):
            guild_id = ctx.guild_id
            author_id = ctx.author['id']
            
            guild_info = cache.get(f"guild_info_{guild_id}")
            if not guild_info:
                async with aiohttp.ClientSession() as session:
                    async with session.get(f"https://discord.com/api/v10/guilds/{guild_id}", headers=ctx.bot.headers) as response:
                        guild_info = await response.json()
                cache.set(f"guild_info_{guild_id}", guild_info)
            if guild_info.get('owner_id') == author_id:
                return await func(ctx, *args, **kwargs)
            await ctx.bot.event_handler.handle_event({
                't': 'on_error',
                'd': {'message': 'Você precisa ser o dono do servidor para usar este comando.', 'channel_id': ctx.channel_id}
            })
        return wrapper
    return decorator

def has_role(role_name):
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(ctx, *args, **kwargs):
            roles = ctx.member['roles']
            guild_id = ctx.guild_id
            
            guild_roles = cache.get(f"guild_roles_{guild_id}")
            if not guild_roles:
                async with aiohttp.ClientSession() as session:
                    async with session.get(f"https://discord.com/api/v10/guilds/{guild_id}/roles", headers=ctx.bot.headers) as response:
                        guild_roles = await response.json()
                cache.set(f"guild_roles_{guild_id}", guild_roles)
            role_ids = [role['id'] for role in guild_roles if role['name'] == role_name]
            if any(role_id in roles for role_id in role_ids):
                return await func(ctx, *args, **kwargs)
            else:
                await ctx.bot.event_handler.handle_event({
                    't': 'on_error',
                    'd': {'message': f'Você precisa do papel {role_name} para usar este comando.', 'channel_id': ctx.channel_id}
                })
        return wrapper
    return decorator
    
def rate_limit(limit, per, scope="user"):
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(ctx, *args, **kwargs):
            key = f"rate_limit:{scope}:{ctx.guild_id if scope == 'guild' else ctx.channel_id if scope == 'channel' else ctx.author['id']}"
            current = cache.get(key) or 0
            if current >= limit:
                await ctx.bot.event_handler.handle_event({
                    't': 'on_error',
                    'd': {'message': 'Você atingiu o limite de uso deste comando.', 'time_left': per, 'channel_id': ctx.channel_id}
                })
            else:
                cache.set(key, current + 1, ttl=per)
                return await func(ctx, *args, **kwargs)
        return wrapper
    return decorator

def command(name=None, description=None):
    def decorator(func):
        func._command = {
            "name": name or func.__name__,
            "description": description or func.__doc__ or "No description provided",
            "options": []
        }
        
        for param_name, param_type in func.__annotations__.items():
            option = {"name": param_name, "description": "Input text", "required": True}
            if param_type == str:
                option["type"] = 3  # STRING
            elif param_type == bytes:
                option["type"] = 11  # ATTACHMENT
            elif param_type == list:
                option["type"] = 3
                option["description"] = "Comma separated list of texts"
            func._command['options'].append(option)

        return func
    return decorator


Arquivo não encontrado: │  
brazbot/dropdowns.py:

class DropdownOption:
    def __init__(self, label, value, description=None, emoji=None, default=False):
        self.label = label
        self.value = value
        self.description = description
        self.emoji = emoji
        self.default = default

    def to_dict(self):
        data = {
            "label": self.label,
            "value": self.value,
            "default": self.default
        }
        if self.description:
            data["description"] = self.description
        if self.emoji:
            data["emoji"] = self.emoji
        return data

class Dropdown:
    def __init__(self, custom_id, options, placeholder=None, min_values=1, max_values=1, disabled=False):
        self.custom_id = custom_id
        self.options = options
        self.placeholder = placeholder
        self.min_values = min_values
        self.max_values = max_values
        self.disabled = disabled

    def to_dict(self):
        return {
            "type": 3,
            "custom_id": self.custom_id,
            "options": [option.to_dict() for option in self.options],
            "placeholder": self.placeholder,
            "min_values": self.min_values,
            "max_values": self.max_values,
            "disabled": self.disabled
        }

    @property
    def to_component(self):
        return {"type": 1, "components": [self.to_dict()]}

Arquivo não encontrado: │  
brazbot/embed.py:

import datetime
import json

class Embed:
    def __init__(self, title=None, description=None, url=None, color=None):
        self.title = title
        self.description = description
        self.url = url
        self.color = color
        self.timestamp = None
        self.footer = {}
        self.image = {}
        self.thumbnail = {}
        self.author = {}
        self.fields = []

    def set_title(self, title):
        self.title = title
        return self

    def set_description(self, description):
        self.description = description
        return self

    def set_url(self, url):
        self.url = url
        return self

    def set_color(self, color):
        self.color = color
        return self

    def set_timestamp(self, timestamp=None):
        if timestamp is None:
            timestamp = datetime.datetime.utcnow()
        self.timestamp = timestamp.isoformat()
        return self

    def set_footer(self, text, icon_url=None):
        self.footer = {"text": text}
        if icon_url:
            self.footer["icon_url"] = icon_url
        return self

    def set_image(self, url):
        self.image = {"url": url}
        return self

    def set_thumbnail(self, url):
        self.thumbnail = {"url": url}
        return self

    def set_author(self, name, url=None, icon_url=None):
        self.author = {"name": name}
        if url:
            self.author["url"] = url
        if icon_url:
            self.author["icon_url"] = icon_url
        return self

    def add_field(self, name, value, inline=True):
        self.fields.append({"name": name, "value": value, "inline": inline})
        return self

    def to_dict(self):
        embed = {}
        if self.title:
            embed["title"] = self.title
        if self.description:
            embed["description"] = self.description
        if self.url:
            embed["url"] = self.url
        if self.color:
            embed["color"] = self.color
        if self.timestamp:
            embed["timestamp"] = self.timestamp
        if self.footer:
            embed["footer"] = self.footer
        if self.image:
            embed["image"] = self.image
        if self.thumbnail:
            embed["thumbnail"] = self.thumbnail
        if self.author:
            embed["author"] = self.author
        if self.fields:
            embed["fields"] = self.fields
        return embed

    def to_json(self):
        return json.dumps(self.to_dict(), indent=4)



Arquivo não encontrado: │  
brazbot/events.py:

class EventHandler:
    def __init__(self):
        self.events = {}

    def register(self, event_name, func):
        self.events[event_name] = func

    async def handle_event(self, message):
        event_type = message['t']
        event_data = message['d']
        if event_type in self.events:
            await self.events[event_type](event_data)


Arquivo não encontrado: │  
brazbot/file.py:

class File:
    def __init__(self, file_path):
        self.file_path = file_path

    def to_dict(self):
        return {
            "file": open(self.file_path, 'rb')
        }


Arquivo não encontrado: │  
brazbot/forms.py:

class FormField:
    def __init__(self, label, placeholder, custom_id, style=1, type="SHORT", options=None, min_length=None, max_length=None, required=True):
        self.label = label
        self.placeholder = placeholder
        self.custom_id = custom_id
        self.style = style
        self.type = type
        self.options = options
        self.min_length = min_length
        self.max_length = max_length
        self.required = required

    def to_dict(self):
        data = {
            "label": self.label,
            "custom_id": self.custom_id,
            "style": self.style,
            "placeholder": self.placeholder,
            "required": self.required,
            "type": 4  # Default type for Text Input
        }
        if self.type == "DROPDOWN":
            data["type"] = 3  # Type for Select Menu
            data["options"] = self.options
        if self.min_length is not None:
            data["min_length"] = self.min_length
        if self.max_length is not None:
            data["max_length"] = self.max_length
        if self.placeholder is not None:
            data["placeholder"] = self.placeholder
        return data

class Form:
    def __init__(self, title, custom_id, fields):
        self.title = title
        self.custom_id = custom_id
        self.fields = fields

    def to_dict(self):
        return {
            "type": 1,  # Main Modal type
            "title": self.title,
            "custom_id": self.custom_id,
            "components": [
                {"type": 1, "components": [field.to_dict()]} for field in self.fields
            ]
        }

    @property
    def to_component(self):

        return {
            'type': 9, 
            'data': self.to_dict()
        }


Arquivo não encontrado: │  
brazbot/greedy_union.py:

from typing import TypeVar, Generic, List

T = TypeVar('T')

class Greedy(Generic[T]):
    def __init__(self, values: List[T]):
        self.values = values

    def __iter__(self):
        return iter(self.values)

    def __repr__(self):
        return f"Greedy({self.values})"


Arquivo não encontrado: │  
brazbot/guilds.py:

import aiohttp
from datetime import datetime
from brazbot.member import Member

class Guild:
	def __init__(self, data, bot=None):
		self.bot = bot
		self.id = data.get('id')
		self.name = data.get('name')
		self.icon = data.get('icon')
		self.splash = data.get('splash')
		self.discovery_splash = data.get('discovery_splash')
		self.owner_id = data.get('owner_id')
		self.owner = data.get('owner')
		self.permissions = data.get('permissions')
		self.region = data.get('region')
		self.afk_channel = data.get('afk_channel')
		self.afk_timeout = data.get('afk_timeout')
		self.widget_enabled = data.get('widget_enabled')
		self.widget_channel = data.get('widget_channel')
		self.verification_level = data.get('verification_level')
		self.default_notifications = data.get('default_notifications')
		self.explicit_content_filter = data.get('explicit_content_filter')
		self.roles = data.get('roles', [])
		self.emojis = data.get('emojis', [])
		self.features = data.get('features', [])
		self.mfa_level = data.get('mfa_level')
		self.application_id = data.get('application_id')
		self.system_channel = data.get('system_channel')
		self.system_channel_flags = data.get('system_channel_flags')
		self.rules_channel = data.get('rules_channel')
		self.max_presences = data.get('max_presences')
		self.max_members = data.get('max_members')
		self.vanity_url_code = data.get('vanity_url_code')
		self.description = data.get('description')
		self.banner = data.get('banner')
		self.premium_tier = data.get('premium_tier')
		self.premium_subscription_count = data.get('premium_subscription_count')
		self.preferred_locale = data.get('preferred_locale')
		self.public_updates_channel = data.get('public_updates_channel')
		self.max_video_channel_users = data.get('max_video_channel_users')
		self.approximate_member_count = data.get('approximate_member_count')
		self.approximate_presence_count = data.get('approximate_presence_count')
		self.welcome_screen = data.get('welcome_screen')
		self.nsfw_level = data.get('nsfw_level')
		self.premium_progress_bar_enabled = data.get('premium_progress_bar_enabled')
		self.large = data.get('large')
		self.member_count = data.get('member_count')
		self.members = data.get('members', [])
		self.channels = data.get('channels', [])
		self.threads = data.get('threads', [])
		self.stage_channels = data.get('stage_channels', [])
		self.voice_channels = data.get('voice_channels', [])
		self.categories = data.get('categories', [])
		self.shard_id = data.get('shard_id')
		self.unavailable = data.get('unavailable')
		self.invites_paused_until = data.get('invites_paused_until')
		self.dms_paused_until = data.get('dms_paused_until')
		self.filesize_limit = data.get('filesize_limit')
		self.emoji_limit = data.get('emoji_limit')
		self.sticker_limit = data.get('sticker_limit')
		self.stage_instances = data.get('stage_instances', [])
		self.scheduled_events = data.get('scheduled_events', [])
		self.default_role = data.get('default_role')
		self.self_role = data.get('self_role')
		self.public_updates_channel_id = data.get('public_updates_channel_id')
		self.created_at = datetime.fromtimestamp(((int(self.id) >> 22) + 1420070400000) / 1000)

	@classmethod
	async def from_guild_id(cls, bot, guild_id):
		url = f"https://discord.com/api/v10/guilds/{guild_id}"
		headers = {
			"Authorization": f"Bot {bot.token}"
		}

		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					data = await response.json()
					return cls(data, bot)
				else:
					raise Exception(f"Failed to fetch guild data: {response.status}")

	def __str__(self):
		return self.name

	# Method to count roles using lambda and yield
	def roles_count(self):
		count = lambda: (yield from (role for role in self.roles))
		return sum(1 for _ in count())

	# Method to fetch all members with pagination and concurrency
	async def fetch_all_members(self):
		members = []
		limit = 1000
		after = None
		try:
			async def fetch_page(after):
				params = {'limit': limit}
				if after:
					params['after'] = after

				url = f"https://discord.com/api/v10/guilds/{self.id}/members"
				headers = {
					"Authorization": f"Bot {self.bot.token}"
				}

				async with aiohttp.ClientSession() as session:
					async with session.get(url, headers=headers, params=params) as response:
						if response.status == 429:
							retry_after = int(response.headers.get('Retry-After', 1))
							await asyncio.sleep(retry_after)
							return await fetch_page(after)
						elif response.status != 200:
							raise Exception(f"Failed to fetch members: {response.status}")
						
						data = await response.json()
						return data

			while True:
				data = await fetch_page(after)
				if not data:
					break

				for member_data in data:
					member = Member(member_data, self.bot)
					members.append(member)

				after = data[-1]['user']['id']
				if len(data) < limit:
					break

				# Sleep to respect rate limits
				await asyncio.sleep(1)
		except Exception as e:
			print(e)

		return members


	# Methods to interact with the Discord API
	async def active_threads(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/threads/active"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch active threads: {response.status}")

	async def audit_logs(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/audit-logs"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch audit logs: {response.status}")

	async def ban(self, user_id, delete_message_days=0, reason=None):
		url = f"https://discord.com/api/v10/guilds/{self.id}/bans/{user_id}"
		headers = {
			"Authorization": f"Bot {self.bot.token}",
			"Content-Type": "application/json"
		}
		json_data = {
			"delete_message_days": delete_message_days,
			"reason": reason
		}
		async with aiohttp.ClientSession() as session:
			async with session.put(url, headers=headers, json=json_data) as response:
				if response.status != 204:
					raise Exception(f"Failed to ban user {user_id}: {response.status}")

	async def bans(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/bans"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch bans: {response.status}")

	async def bulk_ban(self, user_ids, delete_message_days=0, reason=None):
		for user_id in user_ids:
			await self.ban(user_id, delete_message_days, reason)

	async def by_category(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/channels"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					channels = await response.json()
					categories = {}
					for channel in channels:
						category_id = channel.get('parent_id')
						if category_id not in categories:
							categories[category_id] = []
						categories[category_id].append(channel)
					return categories
				else:
					raise Exception(f"Failed to fetch channels by category: {response.status}")

	async def change_voice_state(self, channel_id, self_mute=False, self_deaf=False):
		url = f"https://discord.com/api/v10/guilds/{self.id}/voice-states/@me"
		headers = {
			"Authorization": f"Bot {self.bot.token}",
			"Content-Type": "application/json"
		}
		json_data = {
			"channel_id": channel_id,
			"self_mute": self_mute,
			"self_deaf": self_deaf
		}
		async with aiohttp.ClientSession() as session:
			async with session.patch(url, headers=headers, json=json_data) as response:
				if response.status != 204:
					raise Exception(f"Failed to change voice state: {response.status}")

	async def chunk(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/members?limit=1000"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to chunk members: {response.status}")

	async def create_automod_rule(self, data):
		url = f"https://discord.com/api/v10/guilds/{self.id}/auto-moderation/rules"
		headers = {
			"Authorization": f"Bot {self.bot.token}",
			"Content-Type": "application/json"
		}
		async with aiohttp.ClientSession() as session:
			async with session.post(url, headers=headers, json=data) as response:
				if response.status != 201:
					raise Exception(f"Failed to create automod rule: {response.status}")

	async def create_category(self, name, reason=None):
		return await self.create_channel(name, 4, reason=reason)

	async def create_channel(self, name, type, reason=None):
		url = f"https://discord.com/api/v10/guilds/{self.id}/channels"
		headers = {
			"Authorization": f"Bot {self.bot.token}",
			"Content-Type": "application/json"
		}
		json_data = {
			"name": name,
			"type": type,
			"reason": reason
		}
		async with aiohttp.ClientSession() as session:
			async with session.post(url, headers=headers, json=json_data) as response:
				if response.status == 201:
					return await response.json()
				else:
					raise Exception(f"Failed to create channel: {response.status}")

	async def create_custom_emoji(self, name, image, roles=None, reason=None):
		url = f"https://discord.com/api/v10/guilds/{self.id}/emojis"
		headers = {
			"Authorization": f"Bot {self.bot.token}",
			"Content-Type": "application/json"
		}
		json_data = {
			"name": name,
			"image": image,
			"roles": roles,
			"reason": reason
		}
		async with aiohttp.ClientSession() as session:
			async with session.post(url, headers=headers, json=json_data) as response:
				if response.status == 201:
					return await response.json()
				else:
					raise Exception(f"Failed to create custom emoji: {response.status}")

	async def create_forum(self, name, reason=None):
		return await self.create_channel(name, 15, reason=reason)

	async def create_integration(self, type, id):
		url = f"https://discord.com/api/v10/guilds/{self.id}/integrations"
		headers = {
			"Authorization": f"Bot {self.bot.token}",
			"Content-Type": "application/json"
		}
		json_data = {
			"type": type,
			"id": id
		}
		async with aiohttp.ClientSession() as session:
			async with session.post(url, headers=headers, json=json_data) as response:
				if response.status != 204:
					raise Exception(f"Failed to create integration: {response.status}")

	async def create_role(self, data):
		url = f"https://discord.com/api/v10/guilds/{self.id}/roles"
		headers = {
			"Authorization": f"Bot {self.bot.token}",
			"Content-Type": "application/json"
		}
		async with aiohttp.ClientSession() as session:
			async with session.post(url, headers=headers, json=data) as response:
				if response.status == 201:
					return await response.json()
				else:
					raise Exception(f"Failed to create role: {response.status}")

	async def create_scheduled_event(self, data):
		url = f"https://discord.com/api/v10/guilds/{self.id}/scheduled-events"
		headers = {
			"Authorization": f"Bot {self.bot.token}",
			"Content-Type": "application/json"
		}
		async with aiohttp.ClientSession() as session:
			async with session.post(url, headers=headers, json=data) as response:
				if response.status == 201:
					return await response.json()
				else:
					raise Exception(f"Failed to create scheduled event: {response.status}")

	async def create_stage_channel(self, name, reason=None):
		return await self.create_channel(name, 13, reason=reason)

	async def create_sticker(self, data):
		url = f"https://discord.com/api/v10/guilds/{self.id}/stickers"
		headers = {
			"Authorization": f"Bot {self.bot.token}",
			"Content-Type": "application/json"
		}
		async with aiohttp.ClientSession() as session:
			async with session.post(url, headers=headers, json=data) as response:
				if response.status == 201:
					return await response.json()
				else:
					raise Exception(f"Failed to create sticker: {response.status}")

	async def create_template(self, data):
		url = f"https://discord.com/api/v10/guilds/{self.id}/templates"
		headers = {
			"Authorization": f"Bot {self.bot.token}",
			"Content-Type": "application/json"
		}
		async with aiohttp.ClientSession() as session:
			async with session.post(url, headers=headers, json=data) as response:
				if response.status == 201:
					return await response.json()
				else:
					raise Exception(f"Failed to create template: {response.status}")

	async def create_text_channel(self, name, reason=None):
		return await self.create_channel(name, 0, reason=reason)

	async def create_voice_channel(self, name, reason=None):
		return await self.create_channel(name, 2, reason=reason)

	async def delete(self, reason=None):
		url = f"https://discord.com/api/v10/guilds/{self.id}"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.delete(url, headers=headers) as response:
				if response.status != 204:
					raise Exception(f"Failed to delete guild: {response.status}")

	async def delete_emoji(self, emoji_id, reason=None):
		url = f"https://discord.com/api/v10/guilds/{self.id}/emojis/{emoji_id}"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.delete(url, headers=headers) as response:
				if response.status != 204:
					raise Exception(f"Failed to delete emoji: {response.status}")

	async def delete_sticker(self, sticker_id, reason=None):
		url = f"https://discord.com/api/v10/guilds/{self.id}/stickers/{sticker_id}"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.delete(url, headers=headers) as response:
				if response.status != 204:
					raise Exception(f"Failed to delete sticker: {response.status}")

	def dms_paused(self):
		return self.dms_paused_until is not None

	async def edit(self, **fields):
		url = f"https://discord.com/api/v10/guilds/{self.id}"
		headers = {
			"Authorization": f"Bot {self.bot.token}",
			"Content-Type": "application/json"
		}
		async with aiohttp.ClientSession() as session:
			async with session.patch(url, headers=headers, json=fields) as response:
				if response.status != 200:
					raise Exception(f"Failed to edit guild: {response.status}")

	async def edit_role_positions(self, roles):
		url = f"https://discord.com/api/v10/guilds/{self.id}/roles"
		headers = {
			"Authorization": f"Bot {self.bot.token}",
			"Content-Type": "application/json"
		}
		async with aiohttp.ClientSession() as session:
			async with session.patch(url, headers=headers, json=roles) as response:
				if response.status != 200:
					raise Exception(f"Failed to edit role positions: {response.status}")

	async def edit_welcome_screen(self, data):
		url = f"https://discord.com/api/v10/guilds/{self.id}/welcome-screen"
		headers = {
			"Authorization": f"Bot {self.bot.token}",
			"Content-Type": "application/json"
		}
		async with aiohttp.ClientSession() as session:
			async with session.patch(url, headers=headers, json=data) as response:
				if response.status != 200:
					raise Exception(f"Failed to edit welcome screen: {response.status}")

	async def edit_widget(self, data):
		url = f"https://discord.com/api/v10/guilds/{self.id}/widget"
		headers = {
			"Authorization": f"Bot {self.bot.token}",
			"Content-Type": "application/json"
		}
		async with aiohttp.ClientSession() as session:
			async with session.patch(url, headers=headers, json=data) as response:
				if response.status != 200:
					raise Exception(f"Failed to edit widget: {response.status}")

	async def estimate_pruned_members(self, days):
		url = f"https://discord.com/api/v10/guilds/{self.id}/prune"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers, params={'days': days}) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to estimate pruned members: {response.status}")

	async def fetch_automod_rule(self, rule_id):
		url = f"https://discord.com/api/v10/guilds/{self.id}/auto-moderation/rules/{rule_id}"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch automod rule: {response.status}")

	async def fetch_automod_rules(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/auto-moderation/rules"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch automod rules: {response.status}")

	async def fetch_ban(self, user_id):
		url = f"https://discord.com/api/v10/guilds/{self.id}/bans/{user_id}"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch ban: {response.status}")

	async def fetch_channel(self, channel_id):
		url = f"https://discord.com/api/v10/channels/{channel_id}"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch channel: {response.status}")

	async def fetch_channels(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/channels"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch channels: {response.status}")

	async def fetch_emoji(self, emoji_id):
		url = f"https://discord.com/api/v10/guilds/{self.id}/emojis/{emoji_id}"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch emoji: {response.status}")

	async def fetch_emojis(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/emojis"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch emojis: {response.status}")

	async def fetch_member(self, user_id):
		url = f"https://discord.com/api/v10/guilds/{self.id}/members/{user_id}"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch member: {response.status}")

	async def fetch_members(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/members"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch members: {response.status}")

	async def fetch_roles(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/roles"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch roles: {response.status}")

	async def fetch_scheduled_event(self, event_id):
		url = f"https://discord.com/api/v10/guilds/{self.id}/scheduled-events/{event_id}"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch scheduled event: {response.status}")

	async def fetch_scheduled_events(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/scheduled-events"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch scheduled events: {response.status}")

	async def fetch_sticker(self, sticker_id):
		url = f"https://discord.com/api/v10/guilds/{self.id}/stickers/{sticker_id}"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch sticker: {response.status}")

	async def fetch_stickers(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/stickers"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch stickers: {response.status}")

	def get_channel(self, channel_id):
		return next((channel for channel in self.channels if channel['id'] == channel_id), None)

	def get_channel_or_thread(self, channel_id):
		for collection in [self.channels, self.threads]:
			for item in collection:
				if item['id'] == channel_id:
					return item
		return None

	def get_emoji(self, emoji_id):
		return next((emoji for emoji in self.emojis if emoji['id'] == emoji_id), None)

	def get_member(self, user_id):
		return next((member for member in self.members if member['id'] == user_id), None)

	def get_member_named(self, name):
		return next((member for member in self.members if member['username'] == name), None)

	def get_role(self, role_id):
		return next((role for role in self.roles if role['id'] == role_id), None)

	def get_scheduled_event(self, event_id):
		return next((event for event in self.scheduled_events if event['id'] == event_id), None)

	def get_stage_instance(self, stage_id):
		return next((instance for instance in self.stage_instances if instance['id'] == stage_id), None)

	def get_thread(self, thread_id):
		return next((thread for thread in self.threads if thread['id'] == thread_id), None)

	async def integrations(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/integrations"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch integrations: {response.status}")

	async def invites(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/invites"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch invites: {response.status}")

	def invites_paused(self):
		return self.invites_paused_until is not None

	async def kick(self, user_id, reason=None):
		url = f"https://discord.com/api/v10/guilds/{self.id}/members/{user_id}"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.delete(url, headers=headers) as response:
				if response.status != 204:
					raise Exception(f"Failed to kick member {user_id}: {response.status}")

	async def leave(self):
		url = f"https://discord.com/api/v10/users/@me/guilds/{self.id}"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.delete(url, headers=headers) as response:
				if response.status != 204:
					raise Exception(f"Failed to leave guild: {response.status}")

	async def prune_members(self, days, reason=None):
		url = f"https://discord.com/api/v10/guilds/{self.id}/prune"
		headers = {
			"Authorization": f"Bot {self.bot.token}",
			"Content-Type": "application/json"
		}
		json_data = {
			"days": days,
			"reason": reason
		}
		async with aiohttp.ClientSession() as session:
			async with session.post(url, headers=headers, json=json_data) as response:
				if response.status != 204:
					raise Exception(f"Failed to prune members: {response.status}")

	async def query_members(self, query, limit=10):
		url = f"https://discord.com/api/v10/guilds/{self.id}/members/search"
		headers = {
			"Authorization": f"Bot {self.bot.token}",
			"Content-Type": "application/json"
		}
		params = {
			"query": query,
			"limit": limit
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers, params=params) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to query members: {response.status}")

	async def templates(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/templates"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch templates: {response.status}")

	async def unban(self, user_id, reason=None):
		url = f"https://discord.com/api/v10/guilds/{self.id}/bans/{user_id}"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.delete(url, headers=headers) as response:
				if response.status != 204:
					raise Exception(f"Failed to unban user {user_id}: {response.status}")

	async def vanity_invite(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/vanity-url"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch vanity invite: {response.status}")

	async def webhooks(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/webhooks"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch webhooks: {response.status}")

	async def welcome_screen(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/welcome-screen"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch welcome screen: {response.status}")

	async def widget(self):
		url = f"https://discord.com/api/v10/guilds/{self.id}/widget.json"
		headers = {
			"Authorization": f"Bot {self.bot.token}"
		}
		async with aiohttp.ClientSession() as session:
			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					return await response.json()
				else:
					raise Exception(f"Failed to fetch widget: {response.status}")


Arquivo não encontrado: │  
brazbot/__init__.py:



Arquivo não encontrado: │  
brazbot/literal_arguments.py:

from typing import Literal

def literal_command(bot, name=None, description=None):
    def decorator(func):
        bot.command_handler.register_command(func, name, description)
        return func
    return decorator


Arquivo não encontrado: │  
brazbot/member.py:

import aiohttp
from datetime import datetime

class Member:
    def __init__(self, data, bot=None):
        self.bot = bot
        self.id = data.get('id')
        self.username = data.get('username')
        self.discriminator = data.get('discriminator')
        self.avatar = data.get('avatar')
        self.bot = data.get('bot', False)
        self.system = data.get('system', False)
        self.mfa_enabled = data.get('mfa_enabled', False)
        self.locale = data.get('locale')
        self.verified = data.get('verified', False)
        self.email = data.get('email')
        self.flags = data.get('flags', 0)
        self.premium_type = data.get('premium_type', 0)
        self.public_flags = data.get('public_flags', 0)
        self.accent_color = data.get('accent_color')
        self.accent_colour = self.accent_color
        self.activities = data.get('activities', [])
        self.activity = self.activities[0] if self.activities else None
        self.avatar_decoration = data.get('avatar_decoration')
        self.avatar_decoration_sku_id = data.get('avatar_decoration_sku_id')
        self.banner = data.get('banner')
        self.color = self.accent_color
        self.colour = self.color
        self.created_at = datetime.fromisoformat(data.get('created_at')) if data.get('created_at') else None
        self.default_avatar = f"https://cdn.discordapp.com/embed/avatars/{int(self.discriminator) % 5}.png"
        self.desktop_status = data.get('desktop_status')
        self.display_avatar = self.avatar
        self.display_icon = self.avatar
        self.display_name = data.get('display_name', self.username)
        self.dm_channel = data.get('dm_channel')
        self.global_name = data.get('global_name')
        self.guild = data.get('guild')
        self.guild_avatar = data.get('guild_avatar')
        self.guild_permissions = data.get('guild_permissions')
        self.joined_at = datetime.fromisoformat(data.get('joined_at')) if data.get('joined_at') else None
        self.mention = f"<@{self.id}>"
        self.mobile_status = data.get('mobile_status')
        self.mutual_guilds = data.get('mutual_guilds', [])
        self.name = self.username
        self.nick = data.get('nick')
        self.pending = data.get('pending', False)
        self.premium_since = datetime.fromisoformat(data.get('premium_since')) if data.get('premium_since') else None
        self.raw_status = data.get('raw_status')
        self.resolved_permissions = data.get('resolved_permissions')
        self.roles = data.get('roles', [])
        self.status = data.get('status')
        self.system = data.get('system', False)
        self.timed_out_until = datetime.fromisoformat(data.get('timed_out_until')) if data.get('timed_out_until') else None
        self.top_role = data.get('top_role')
        self.voice = data.get('voice')
        self.web_status = data.get('web_status')

    @classmethod
    async def from_user_id(cls, bot, user_id, guild_id=None):
        url = f"https://discord.com/api/v10/users/{user_id}"
        headers = {
            "Authorization": f"Bot {bot.token}"
        }

        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    data = await response.json()
                    return cls(data, bot)
                else:
                    raise Exception(f"Failed to fetch user data: {response.status}")

    def __str__(self):
        return f"{self.username}#{self.discriminator}"

    # Methods to interact with the Discord API
    async def add_roles(self, *roles):
        url = f"https://discord.com/api/v10/guilds/{self.guild['id']}/members/{self.id}/roles"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        async with aiohttp.ClientSession() as session:
            for role in roles:
                async with session.put(f"{url}/{role.id}", headers=headers) as response:
                    if response.status != 204:
                        raise Exception(f"Failed to add role {role.id} to member {self.id}: {response.status}")

    async def ban(self, reason=None, delete_message_days=0):
        url = f"https://discord.com/api/v10/guilds/{self.guild['id']}/bans/{self.id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        json_data = {
            "delete_message_days": delete_message_days,
            "reason": reason
        }
        async with aiohttp.ClientSession() as session:
            async with session.put(url, headers=headers, json=json_data) as response:
                if response.status != 204:
                    raise Exception(f"Failed to ban member {self.id}: {response.status}")

    async def create_dm(self):
        url = f"https://discord.com/api/v10/users/@me/channels"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        json_data = {
            "recipient_id": self.id
        }
        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers=headers, json=json_data) as response:
                if response.status == 200:
                    data = await response.json()
                    self.dm_channel = data
                else:
                    raise Exception(f"Failed to create DM channel: {response.status}")

    async def edit(self, **fields):
        url = f"https://discord.com/api/v10/guilds/{self.guild['id']}/members/{self.id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        async with aiohttp.ClientSession() as session:
            async with session.patch(url, headers=headers, json=fields) as response:
                if response.status != 200:
                    raise Exception(f"Failed to edit member {self.id}: {response.status}")

    async def fetch_message(self, channel_id, message_id):
        url = f"https://discord.com/api/v10/channels/{channel_id}/messages/{message_id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    raise Exception(f"Failed to fetch message: {response.status}")

    def get_role(self, role_id):
        return next((role for role in self.roles if role['id'] == role_id), None)

    async def history(self, limit=100):
        url = f"https://discord.com/api/v10/channels/{self.dm_channel['id']}/messages?limit={limit}"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    raise Exception(f"Failed to fetch message history: {response.status}")

    def is_on_mobile(self):
        return self.mobile_status == "online"

    def is_timed_out(self):
        return self.timed_out_until is not None

    async def kick(self, reason=None):
        url = f"https://discord.com/api/v10/guilds/{self.guild['id']}/members/{self.id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.delete(url, headers=headers) as response:
                if response.status != 204:
                    raise Exception(f"Failed to kick member {self.id}: {response.status}")

    async def mentioned_in(self, message):
        return f"<@{self.id}>" in message['content']

    async def move_to(self, channel_id):
        url = f"https://discord.com/api/v10/guilds/{self.guild['id']}/members/{self.id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        json_data = {
            "channel_id": channel_id
        }
        async with aiohttp.ClientSession() as session:
            async with session.patch(url, headers=headers, json=json_data) as response:
                if response.status != 204:
                    raise Exception(f"Failed to move member {self.id} to channel {channel_id}: {response.status}")

    async def pins(self):
        url = f"https://discord.com/api/v10/channels/{self.dm_channel['id']}/pins"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    raise Exception(f"Failed to fetch pinned messages: {response.status}")

    async def remove_roles(self, *roles):
        url = f"https://discord.com/api/v10/guilds/{self.guild['id']}/members/{self.id}/roles"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        async with aiohttp.ClientSession() as session:
            for role in roles:
                async with session.delete(f"{url}/{role.id}", headers=headers) as response:
                    if response.status != 204:
                        raise Exception(f"Failed to remove role {role.id} from member {self.id}: {response.status}")

    async def request_to_speak(self):
        url = f"https://discord.com/api/v10/guilds/{self.guild['id']}/voice-states/{self.id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        json_data = {
            "request_to_speak_timestamp": datetime.utcnow().isoformat()
        }
        async with aiohttp.ClientSession() as session:
            async with session.patch(url, headers=headers, json=json_data) as response:
                if response.status != 204:
                    raise Exception(f"Failed to request to speak: {response.status}")

    async def send(self, content=None, embed=None, embeds=None, files=None, components=None, ephemeral=False):
        if not self.dm_channel:
            await self.create_dm()
        url = f"https://discord.com/api/v10/channels/{self.dm_channel['id']}/messages"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        json_data = {
            "content": content,
            "embed": embed,
            "embeds": embeds,
            "components": components,
            "flags": 64 if ephemeral else 0
        }
        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers=headers, json=json_data) as response:
                if response.status != 200:
                    raise Exception(f"Failed to send message: {response.status}")

    async def timeout(self, duration, reason=None):
        url = f"https://discord.com/api/v10/guilds/{self.guild['id']}/members/{self.id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        json_data = {
            "communication_disabled_until": (datetime.utcnow() + duration).isoformat(),
            "reason": reason
        }
        async with aiohttp.ClientSession() as session:
            async with session.patch(url, headers=headers, json=json_data) as response:
                if response.status != 204:
                    raise Exception(f"Failed to timeout member {self.id}: {response.status}")

    async def typing(self):
        url = f"https://discord.com/api/v10/channels/{self.dm_channel['id']}/typing"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers=headers) as response:
                if response.status != 204:
                    raise Exception(f"Failed to send typing indication: {response.status}")

    async def unban(self):
        url = f"https://discord.com/api/v10/guilds/{self.guild['id']}/bans/{self.id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.delete(url, headers=headers) as response:
                if response.status != 204:
                    raise Exception(f"Failed to unban member {self.id}: {response.status}")


Arquivo não encontrado: │  
brazbot/message_handler.py:

import aiohttp
import logging
import asyncio
import json
from aiohttp import FormData

"""
SEE:    1. https://discord.com/developers/docs/interactions/receiving-and-responding#interaction-response-object
        2. https://discord.com/developers/docs/topics/rate-limits#global-rate-limit
        3. https://discord.com/developers/docs/resources/webhook#edit-webhook-message
"""

class MessageHandler:
    def __init__(self, token):
        self.token = token
        self.base_url = "https://discord.com/api/v10"
        self.headers = {
            "Authorization": f"Bot {self.token}"
        }

    async def send_message(self, channel_id, content):
        url = f"{self.base_url}/channels/{channel_id}/messages"
        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers=self.headers, json={"content": content}) as response:
                if response.status != 200:
                    logging.error(f"Failed to send message: {response.status} - {await response.text()}")
                    return None
                else:
                    response_json = await response.json()
                    logging.info(f"Message sent: {response_json}")
                    return response_json

    async def send_embed(self, channel_id, embed):
        url = f"{self.base_url}/channels/{channel_id}/messages"
        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers=self.headers, json={"embeds": [embed]}) as response:
                if response.status != 200:
                    logging.error(f"Failed to send embed: {response.status} - {await response.text()}")
                    return None
                else:
                    response_json = await response.json()
                    logging.info(f"Embed sent: {response_json}")
                    return response_json

    async def send_file(self, channel_id, file_path):
        url = f"{self.base_url}/channels/{channel_id}/messages"
        with open(file_path, 'rb') as file:
            form = FormData()
            form.add_field('file', file, filename=file_path)
            async with aiohttp.ClientSession() as session:
                async with session.post(url, headers=self.headers, data=form) as response:
                    if response.status != 200:
                        logging.error(f"Failed to send file: {response.status} - {await response.text()}")
                        return None
                    else:
                        response_json = await response.json()
                        logging.info(f"File sent: {response_json}")
                        return response_json

    async def edit_message(self, channel_id, message_id, content=None, embed=None, files=None, components=None):
        url = f"{self.base_url}/channels/{channel_id}/messages/{message_id}"
        data = {}
        if content:
            data["content"] = content
        if embed:
            data["embeds"] = [embed] if isinstance(embed, dict) else embed
        if components:
            data["components"] = components

        async with aiohttp.ClientSession() as session:
            if files:
                form = FormData()
                form.add_field('payload_json', json.dumps(data))
                for file in files:
                    form.add_field('file', file['data'], filename=file['filename'], content_type=file['content_type'])
                async with session.patch(url, headers=self.headers, data=form) as response:
                    if response.status != 200:
                        logging.error(f"Failed to edit message with file: {response.status} - {await response.text()}")
                        return None
                    else:
                        response_json = await response.json()
                        logging.info(f"Message edited with file: {response_json}")
                        return response_json
            else:
                async with session.patch(url, headers=self.headers, json=data) as response:
                    if response.status != 200:
                        logging.error(f"Failed to edit message: {response.status} - {await response.text()}")
                        return None
                    else:
                        response_json = await response.json()
                        logging.info(f"Message edited: {response_json}")
                        return response_json

    async def send_interaction(self, interaction, content=None, embed=None, embeds=None, files=None, components=None, ephemeral=False):
        url = f"{self.base_url}/interactions/{interaction['id']}/{interaction['token']}/callback"
        data = {
            "type": 4,
            "data": {}
        }
        if content:
            data["data"]["content"] = str(content)  # Ensure content is a string
        if embed:
            data["data"]["embeds"] = [embed]
        if embeds:
            data["data"]["embeds"] = embeds
        if files:
            data["data"]["attachments"] = files
        if components:
            data["data"]["components"] = components
        if ephemeral:
            data["data"]["flags"] = 64  # This flag makes the response ephemeral

        logging.debug(f"send_interaction payload: {json.dumps(data, indent=2)}")

        async with aiohttp.ClientSession() as session:
            if files:
                form = FormData()
                form.add_field('payload_json', json.dumps(data))
                for file in files:
                    form.add_field('file', file['data'], filename=file['filename'], content_type=file['content_type'])
                async with session.post(url, headers={"Authorization": self.headers["Authorization"]}, data=form) as response:
                    if response.status == 429:  # Rate limit
                        retry_after = int(response.headers.get("Retry-After", 1))
                        logging.error(f"Rate limited. Retrying after {retry_after} seconds.")
                        await asyncio.sleep(retry_after)
                        return await self.send_interaction(interaction, content, embed, embeds, files, components, ephemeral)
                    elif response.status != 200:
                        logging.error(f"Failed to send interaction: {response.status} - {await response.text()}")
                        return None
                    else:
                        response_json = await response.json()
                        logging.info(f"Interaction sent: {response_json}")
                        return response_json
            else:
                async with session.post(url, headers=self.headers, json=data) as response:
                    if response.status == 429:  # Rate limit
                        retry_after = int(response.headers.get("Retry-After", 1))
                        logging.error(f"Rate limited. Retrying after {retry_after} seconds.")
                        await asyncio.sleep(retry_after)
                        return await self.send_interaction(interaction, content, embed, embeds, files, components, ephemeral)
                    elif response.status != 200:
                        logging.error(f"Failed to send interaction: {response.status} - {await response.text()}")
                        return None
                    else:
                        response_json = await response.json()
                        logging.info(f"Interaction sent: {response_json}")
                        return response_json

    async def send_followup_message(self, application_id, interaction_token, content=None, embed=None, embeds=None, files=None, components=None, ephemeral=False):
        url = f"{self.base_url}/webhooks/{application_id}/{interaction_token}"
        data = {
            "content": str(content) if content else "",
            "embeds": [embed] if embed else embeds,
            "components": components,
            "attachments": files,
            "flags": 64 if ephemeral else 0
        }

        logging.debug(f"send_followup_message payload: {json.dumps(data, indent=2)}")

        async with aiohttp.ClientSession() as session:
            if files:
                form = FormData()
                form.add_field('payload_json', json.dumps(data))
                for file in files:
                    form.add_field('file', file['data'], filename=file['filename'], content_type=file['content_type'])
                async with session.post(url, headers={"Authorization": self.headers["Authorization"]}, data=form) as response:
                    if response.status == 429:  # Rate limit
                        retry_after = int(response.headers.get("Retry-After", 1))
                        logging.error(f"Rate limited. Retrying after {retry_after} seconds.")
                        await asyncio.sleep(retry_after)
                        return await self.send_followup_message(application_id, interaction_token, content, embed, embeds, files, components, ephemeral)
                    elif response.status != 200:
                        logging.error(f"Failed to send follow-up message: {response.status} - {await response.text()}")
                        return None
                    else:
                        response_json = await response.json()
                        logging.info(f"Follow-up message sent: {response_json}")
                        return response_json
            else:
                async with session.post(url, headers=self.headers, json=data) as response:
                    if response.status == 429:  # Rate limit
                        retry_after = int(response.headers.get("Retry-After", 1))
                        logging.error(f"Rate limited. Retrying after {retry_after} seconds.")
                        await asyncio.sleep(retry_after)
                        return await self.send_followup_message(application_id, interaction_token, content, embed, embeds, files, components, ephemeral)
                    elif response.status != 200:
                        logging.error(f"Failed to send follow-up message: {response.status} - {await response.text()}")
                        return None
                    else:
                        response_json = await response.json()
                        logging.info(f"Follow-up message sent: {response_json}")
                        return response_json


    #https://discord.com/developers/docs/interactions/message-components#text-inputs
    async def send_modal(self, interaction, title, custom_id, data):
        url = f"{self.base_url}/interactions/{interaction['id']}/{interaction['token']}/callback"

        logging.debug(f"send_modal payload: {json.dumps(data, indent=2)}")

        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers=self.headers, json=data) as response:
                if response.status == 429:  # Rate limit
                    retry_after = int(response.headers.get("Retry-After", 1))
                    logging.error(f"Rate limited. Retrying after {retry_after} seconds.")
                    #await asyncio.sleep(retry_after)
                    return await self.send_modal(interaction, title, custom_id, components)
                elif response.status != 200:
                    logging.error(f"Failed to send modal: {response.status} - {await response.text()}")
                    return None
                else:
                    response_json = await response.json()
                    logging.info(f"Modal sent: {response_json}")
                    return response_json

    async def delete_message(self, channel_id, message_id):
        url = f"{self.base_url}/channels/{channel_id}/messages/{message_id}"
        async with aiohttp.ClientSession() as session:
            async with session.delete(url, headers=self.headers) as response:
                if response.status != 204:
                    logging.error(f"Failed to delete message: {response.status} - {await response.text()}")
                    return False
                else:
                    logging.info(f"Message deleted")
                    return True

    async def add_reaction(self, channel_id, message_id, emoji):
        url = f"{self.base_url}/channels/{channel_id}/messages/{message_id}/reactions/{emoji}/@me"
        async with aiohttp.ClientSession() as session:
            async with session.put(url, headers=self.headers) as response:
                if response.status != 204:
                    logging.error(f"Failed to add reaction: {response.status} - {await response.text()}")
                    return False
                else:
                    logging.info(f"Reaction added")
                    return True

    async def remove_reaction(self, channel_id, message_id, emoji, user_id):
        url = f"{self.base_url}/channels/{channel_id}/messages/{message_id}/reactions/{emoji}/{user_id}"
        async with aiohttp.ClientSession() as session:
            async with session.delete(url, headers=self.headers) as response:
                if response.status != 204:
                    logging.error(f"Failed to remove reaction: {response.status} - {await response.text()}")
                    return False
                else:
                    logging.info(f"Reaction removed")
                    return True

    async def bulk_delete_messages(self, channel_id, message_ids):
        url = f"{self.base_url}/channels/{channel_id}/messages/bulk-delete"
        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers=self.headers, json={"messages": message_ids}) as response:
                if response.status != 204:
                    logging.error(f"Failed to bulk delete messages: {response.status} - {await response.text()}")
                    return False
                else:
                    logging.info(f"Messages bulk deleted")
                    return True

    async def pin_message(self, channel_id, message_id):
        url = f"{self.base_url}/channels/{channel_id}/pins/{message_id}"
        async with aiohttp.ClientSession() as session:
            async with session.put(url, headers=self.headers) as response:
                if response.status != 204:
                    logging.error(f"Failed to pin message: {response.status} - {await response.text()}")
                    return False
                else:
                    logging.info(f"Message pinned")
                    return True

    async def unpin_message(self, channel_id, message_id):
        url = f"{self.base_url}/channels/{channel_id}/pins/{message_id}"
        async with aiohttp.ClientSession() as session:
            async with session.delete(url, headers=self.headers) as response:
                if response.status != 204:
                    logging.error(f"Failed to unpin message: {response.status} - {await response.text()}")
                    return False
                else:
                    logging.info(f"Message unpinned")
                    return True

    async def create_webhook(self, channel_id, name, avatar=None):
        url = f"{self.base_url}/channels/{channel_id}/webhooks"
        json_data = {"name": name}
        if avatar:
            json_data["avatar"] = avatar
        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers=self.headers, json=json_data) as response:
                if response.status != 200:
                    logging.error(f"Failed to create webhook: {response.status} - {await response.text()}")
                    return None
                else:
                    response_json = await response.json()
                    logging.info(f"Webhook created: {response_json}")
                    return response_json

    async def send_webhook_message(self, webhook_url, content=None, username=None, avatar_url=None, embeds=None):
        json_data = {"content": content}
        if username:
            json_data["username"] = username
        if avatar_url:
            json_data["avatar_url"] = avatar_url
        if embeds:
            json_data["embeds"] = embeds
        async with aiohttp.ClientSession() as session:
            async with session.post(webhook_url, json=json_data) as response:
                if response.status != 200:
                    logging.error(f"Failed to send webhook message: {response.status} - {await response.text()}")
                    return None
                else:
                    response_json = await response.json()
                    logging.info(f"Webhook message sent: {response_json}")
                    return response_json



Arquivo não encontrado: │  
brazbot/messages.py:

import aiohttp

class MessageHandler:
    def __init__(self, token):
        self.base_url = "https://discord.com/api/v10"
        self.token = token
        self.headers = {
            "Authorization": f"Bot {self.token}",
            "Content-Type": "application/json"
        }

    async def send_message(self, channel_id, content):
        url = f"{self.base_url}/channels/{channel_id}/messages"
        payload = {
            "content": content
        }
        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers=self.headers, json=payload) as response:
                if response.status != 200:
                    print(f"Failed to send message: {response.status}")
                return await response.json()

    async def send_embed(self, channel_id, embed):
        url = f"{self.base_url}/channels/{channel_id}/messages"
        payload = {
            "embeds": [embed]
        }
        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers=self.headers, json=payload) as response:
                if response.status != 200:
                    print(f"Failed to send embed: {response.status}")
                return await response.json()

    async def send_file(self, channel_id, file_path, content=None):
        url = f"{self.base_url}/channels/{channel_id}/messages"
        data = aiohttp.FormData()
        if content:
            data.add_field('content', content)
        data.add_field('file', open(file_path, 'rb'))
        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers={"Authorization": f"Bot {self.token}"}, data=data) as response:
                if response.status != 200:
                    print(f"Failed to send file: {response.status}")
                return await response.json()

    async def send_image(self, channel_id, image_url, content=None):
        embed = {
            "image": {
                "url": image_url
            }
        }
        return await self.send_embed(channel_id, embed)


Arquivo não encontrado: │  
brazbot/optional_arguments.py:

from typing import Optional

def optional_argument_command(bot, name=None, description=None):
    def decorator(func):
        bot.command_handler.register_command(func, name, description)
        return func
    return decorator


Arquivo não encontrado: │  
brazbot/responses.py:

class InteractionResponse:
    def __init__(self, bot, message):
        self.bot = bot
        self.message = message
        self.interaction_id = message['id']
        self.interaction_token = message['token']

    async def send(self, content=None, embeds=None, embed=None, files=None, ephemeral=False):
        url = f"https://discord.com/api/v10/interactions/{self.interaction_id}/{self.interaction_token}/callback"
        data = {
            "type": 4,  # Type 4 means responding with a message
            "data": {}
        }
        if content:
            data["data"]["content"] = content
        if embeds:
            data["data"]["embeds"] = embeds
        if embed:
            data["data"]["embeds"] = [embed]
        if ephemeral:
            data["data"]["flags"] = 64  # Ephemeral message

        if files:
            multipart_data = aiohttp.FormData()
            multipart_data.add_field('payload_json', json.dumps(data))
            for file in files:
                multipart_data.add_field('file', open(file, 'rb'))
            async with aiohttp.ClientSession() as session:
                async with session.post(url, data=multipart_data, headers={"Authorization": f"Bot {self.bot.token}"}) as response:
                    if response.status != 200:
                        logging.error(f"Failed to send interaction response: {response.status} - {await response.text()}")
                    return await response.json()
        else:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=data, headers={"Authorization": f"Bot {self.bot.token}"}) as response:
                    if response.status != 200:
                        logging.error(f"Failed to send interaction response: {response.status} - {await response.text()}")
                    return await response.json()


Arquivo não encontrado: │  
brazbot/roles.py:

import aiohttp
from datetime import datetime

class Role:
    def __init__(self, data, bot=None):
        self.bot = bot
        self.id = data.get('id')
        self.name = data.get('name')
        self.color = data.get('color')
        self.colour = self.color
        self.created_at = datetime.fromtimestamp(((int(self.id) >> 22) + 1420070400000) / 1000)
        self.display_icon = data.get('icon')
        self.flags = data.get('flags', 0)
        self.guild = data.get('guild')
        self.hoist = data.get('hoist', False)
        self.icon = data.get('icon')
        self.managed = data.get('managed', False)
        self.members = data.get('members', [])
        self.mention = f"<@&{self.id}>"
        self.mentionable = data.get('mentionable', False)
        self.permissions = data.get('permissions')
        self.position = data.get('position')
        self.tags = data.get('tags', {})
        self.unicode_emoji = data.get('unicode_emoji')

    @classmethod
    async def from_role_id(cls, bot, guild_id, role_id):
        url = f"https://discord.com/api/v10/guilds/{guild_id}/roles/{role_id}"
        headers = {
            "Authorization": f"Bot {bot.token}"
        }

        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    data = await response.json()
                    return cls(data, bot)
                else:
                    raise Exception(f"Failed to fetch role data: {response.status}")

    def __str__(self):
        return self.name

    # Methods to interact with the Discord API
    async def delete(self, reason=None):
        url = f"https://discord.com/api/v10/guilds/{self.guild['id']}/roles/{self.id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        async with aiohttp.ClientSession() as session:
            async with session.delete(url, headers=headers) as response:
                if response.status != 204:
                    raise Exception(f"Failed to delete role {self.id}: {response.status}")

    async def edit(self, **fields):
        url = f"https://discord.com/api/v10/guilds/{self.guild['id']}/roles/{self.id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        async with aiohttp.ClientSession() as session:
            async with session.patch(url, headers=headers, json=fields) as response:
                if response.status != 200:
                    raise Exception(f"Failed to edit role {self.id}: {response.status}")

    def is_assignable(self):
        return not self.managed and self.permissions != 0

    def is_bot_managed(self):
        return self.tags.get('bot_id') is not None

    def is_default(self):
        return self.id == self.guild['id']

    def is_integration(self):
        return self.tags.get('integration_id') is not None

    def is_premium_subscriber(self):
        return self.tags.get('premium_subscriber') is not None


Arquivo não encontrado: │  
brazbot/snowflake.py:

class Snowflake:
    """
    TODO:
    A "snowflake" in the context of the Discord API is a unique identifier that 
    represents objects within the platform, such as users, messages, channels, etc. 
    This identifier is a 64-bit number, and contains information about when the object was created.
    """
    @staticmethod
    def is_valid(snowflake):
        try:
            int_snowflake = int(snowflake)
            return int_snowflake > 0
        except (ValueError, TypeError):
            return False

    @staticmethod
    def parse(snowflake):
        if Snowflake.is_valid(snowflake):
            return int(snowflake)
        else:
            raise ValueError(f"Invalid snowflake value: {snowflake}")


Arquivo não encontrado: │  
brazbot/subgroups.py:

class SubCommandGroup:
    def __init__(self, bot, group_name, parent_group_name=None):
        self.bot = bot
        self.group_name = group_name
        self.parent_group_name = parent_group_name

    def command(self, name=None, description=None):
        def decorator(func):
            full_command_name = f"{self.parent_group_name} {self.group_name} {name}" if self.parent_group_name else f"{self.group_name} {name}"
            self.bot.command_handler.register_command(func, full_command_name, description)
            return func
        return decorator

    def subgroup(self, name):
        return SubCommandGroup(self.bot, name, f"{self.parent_group_name} {self.group_name}" if self.parent_group_name else self.group_name)


Arquivo não encontrado: │  
brazbot/threads.py:

import aiohttp
from datetime import datetime

class Thread:
    def __init__(self, data, bot=None):
        self.bot = bot
        self.id = data.get('id')
        self.name = data.get('name')
        self.guild = data.get('guild')
        self.parent_id = data.get('parent_id')
        self.owner_id = data.get('owner_id')
        self.archived = data.get('archived')
        self.archiver_id = data.get('archiver_id')
        self.auto_archive_duration = data.get('auto_archive_duration')
        self.archive_timestamp = data.get('archive_timestamp')
        self.locked = data.get('locked')
        self.slowmode_delay = data.get('slowmode_delay')
        self.invitable = data.get('invitable')
        self.last_message_id = data.get('last_message_id')
        self.last_message = data.get('last_message')
        self.message_count = data.get('message_count')
        self.member_count = data.get('member_count')
        self.created_at = datetime.fromtimestamp(((int(self.id) >> 22) + 1420070400000) / 1000)
        self.category = data.get('category')
        self.category_id = data.get('category_id')
        self.members = data.get('members', [])
        self.flags = data.get('flags')
        self.applied_tags = data.get('applied_tags', [])
        self.type = data.get('type')
        self.mention = f"<#{self.id}>"
        self.jump_url = f"https://discord.com/channels/{self.guild}/{self.id}"

    @classmethod
    async def from_thread_id(cls, bot, guild_id, thread_id):
        url = f"https://discord.com/api/v10/channels/{thread_id}"
        headers = {
            "Authorization": f"Bot {bot.token}"
        }

        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    data = await response.json()
                    data['guild'] = guild_id
                    return cls(data, bot)
                else:
                    raise Exception(f"Failed to fetch thread data: {response.status}")

    def __str__(self):
        return self.name

    # Methods to interact with the Discord API
    async def add_tags(self, tags):
        url = f"https://discord.com/api/v10/channels/{self.id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        json_data = {"applied_tags": tags}
        async with aiohttp.ClientSession() as session:
            async with session.patch(url, headers=headers, json=json_data) as response:
                if response.status != 200:
                    raise Exception(f"Failed to add tags: {response.status}")

    async def add_user(self, user_id):
        url = f"https://discord.com/api/v10/channels/{self.id}/thread-members/{user_id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.put(url, headers=headers) as response:
                if response.status != 204:
                    raise Exception(f"Failed to add user to thread: {response.status}")

    async def delete(self):
        url = f"https://discord.com/api/v10/channels/{self.id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.delete(url, headers=headers) as response:
                if response.status != 204:
                    raise Exception(f"Failed to delete thread: {response.status}")

    async def delete_messages(self, message_ids):
        url = f"https://discord.com/api/v10/channels/{self.id}/messages/bulk-delete"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        json_data = {"messages": message_ids}
        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers=headers, json=json_data) as response:
                if response.status != 204:
                    raise Exception(f"Failed to delete messages: {response.status}")

    async def edit(self, **fields):
        url = f"https://discord.com/api/v10/channels/{self.id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        async with aiohttp.ClientSession() as session:
            async with session.patch(url, headers=headers, json=fields) as response:
                if response.status != 200:
                    raise Exception(f"Failed to edit thread: {response.status}")

    async def fetch_member(self, user_id):
        url = f"https://discord.com/api/v10/channels/{self.id}/thread-members/{user_id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    raise Exception(f"Failed to fetch thread member: {response.status}")

    async def fetch_members(self):
        url = f"https://discord.com/api/v10/channels/{self.id}/thread-members"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    raise Exception(f"Failed to fetch thread members: {response.status}")

    async def fetch_message(self, message_id):
        url = f"https://discord.com/api/v10/channels/{self.id}/messages/{message_id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    raise Exception(f"Failed to fetch message: {response.status}")

    def get_partial_message(self, message_id):
        return {"id": message_id, "channel_id": self.id}

    async def history(self):
        url = f"https://discord.com/api/v10/channels/{self.id}/messages"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    raise Exception(f"Failed to fetch message history: {response.status}")

    def is_news(self):
        return self.type == 5

    def is_nsfw(self):
        return self.flags & 1 << 5 != 0

    def is_private(self):
        return self.type in (2, 12)

    async def join(self):
        url = f"https://discord.com/api/v10/channels/{self.id}/thread-members/@me"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.put(url, headers=headers) as response:
                if response.status != 204:
                    raise Exception(f"Failed to join thread: {response.status}")

    async def leave(self):
        url = f"https://discord.com/api/v10/channels/{self.id}/thread-members/@me"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.delete(url, headers=headers) as response:
                if response.status != 204:
                    raise Exception(f"Failed to leave thread: {response.status}")

    async def permissions_for(self, member_or_role):
        url = f"https://discord.com/api/v10/channels/{self.id}/permissions/{member_or_role.id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    raise Exception(f"Failed to fetch permissions: {response.status}")

    async def pins(self):
        url = f"https://discord.com/api/v10/channels/{self.id}/pins"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    raise Exception(f"Failed to fetch pinned messages: {response.status}")

    async def purge(self, limit):
        url = f"https://discord.com/api/v10/channels/{self.id}/messages"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        params = {"limit": limit}
        async with aiohttp.ClientSession() as session:
            async with session.delete(url, headers=headers, params=params) as response:
                if response.status != 204:
                    raise Exception(f"Failed to purge messages: {response.status}")

    async def remove_tags(self, tags):
        url = f"https://discord.com/api/v10/channels/{self.id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        json_data = {"applied_tags": [tag for tag in self.applied_tags if tag not in tags]}
        async with aiohttp.ClientSession() as session:
            async with session.patch(url, headers=headers, json=json_data) as response:
                if response.status != 200:
                    raise Exception(f"Failed to remove tags: {response.status}")

    async def remove_user(self, user_id):
        url = f"https://discord.com/api/v10/channels/{self.id}/thread-members/{user_id}"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.delete(url, headers=headers) as response:
                if response.status != 204:
                    raise Exception(f"Failed to remove user from thread: {response.status}")

    async def send(self, content):
        url = f"https://discord.com/api/v10/channels/{self.id}/messages"
        headers = {
            "Authorization": f"Bot {self.bot.token}",
            "Content-Type": "application/json"
        }
        json_data = {"content": content}
        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers=headers, json=json_data) as response:
                if response.status != 200:
                    raise Exception(f"Failed to send message: {response.status}")

    async def typing(self):
        url = f"https://discord.com/api/v10/channels/{self.id}/typing"
        headers = {
            "Authorization": f"Bot {self.bot.token}"
        }
        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers=headers) as response:
                if response.status != 204:
                    raise Exception(f"Failed to send typing indicator: {response.status}")


Arquivo não encontrado: │  
brazbot/utils.py:


import uuid

def create_embed(title, description, color=0x5865F2):
    """
    Cria um dicionário de embed para enviar mensagens embutidas no Discord.

    Args:
        title (str): O título do embed.
        description (str): A descrição do embed.
        color (int, opcional): A cor do embed em formato hexadecimal. O padrão é 0x5865F2.

    Returns:
        dict: O dicionário do embed.
    """
    return {
        "title": title,
        "description": description,
        "color": color
    }

def format_command_response(response_text, is_error=False):
    """
    Formata uma resposta de comando com base em se é um erro ou não.

    Args:
        response_text (str): O texto da resposta.
        is_error (bool, opcional): Indica se a resposta é um erro. O padrão é False.

    Returns:
        dict: O dicionário da resposta formatada.
    """
    color = 0xFF0000 if is_error else 0x00FF00
    return create_embed("Resposta do Comando", response_text, color)

def create_error_embed(error_message):
    return {
        "title": "Error",
        "description": error_message,
        "color": 0xFF0000  # Red color for errors
    }

def generate_unique_id(max_length=8):
    """
    Generates a unique integer ID of the specified length.

     Args:
     max_length (int, optional): The maximum length desired for the ID.
     The default value is 8.

     Returns:
     int: A unique integer ID with the specified length.
    """
    # Gerar um UUID
    unique_id = uuid.uuid4()
    
    # Converter o UUID para uma string hexadecimal
    hex_string = str(unique_id.hex)
    
    # Reduzir o tamanho da string hexadecimal para o comprimento especificado
    shortened_hex = hex_string[:max_length]
    
    # Converter a string hexadecimal encurtada de volta para um inteiro
    shortened_int = int(shortened_hex, 16)
    
    return shortened_int

